package org.curieo.consumer;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import lombok.AllArgsConstructor;
import lombok.Generated;
import lombok.Value;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Generated
@Value
@AllArgsConstructor
class StorageSpec {
  private static final Logger LOGGER = LoggerFactory.getLogger(StorageSpec.class);

  String field;
  ExtractType type;
  int size;
  // if the field must be kept unique
  boolean unique;
  String defaultValue;

  IdentityType identityType;

  enum IdentityType {
    Generated,
    Manual,
    NA
  }

  public boolean isIdentityColumn() {
    return identityType != IdentityType.NA;
  }

  StorageSpec(String field, ExtractType type) {
    this(field, type, 0, false, "", IdentityType.NA);
    if (type == ExtractType.String || type == ExtractType.List)
      throw new IllegalArgumentException("VARCHAR types must have a size specified");
  }

  static StorageSpec identity(ExtractType type) {
    switch (type) {
      case SmallInt, Integer, BigInteger -> {
        return new StorageSpec("Id", type, 0, false, "", IdentityType.Generated);
      }
      default ->
          throw new IllegalArgumentException(
              "Identity must be smallint, int, or bigint. Type provided: " + type);
    }
  }

  static StorageSpec identity(String field, ExtractType type) {
    return new StorageSpec(field, type, 0, true, "", IdentityType.Manual);
  }

  StorageSpec(String field, ExtractType type, int size, boolean unique) {
    this(field, type, size, unique, "", IdentityType.NA);
    if (type != ExtractType.String && type != ExtractType.List)
      throw new IllegalArgumentException("Only VARCHAR types can have a size specified");
  }

  StorageSpec(String field, ExtractType type, int size) {
    this(field, type, size, false, "", IdentityType.NA);
    if (type != ExtractType.String && type != ExtractType.List)
      throw new IllegalArgumentException("Only VARCHAR types can have a size specified");
  }

  StorageSpec(String field, ExtractType type, String defaultValue) {
    this(field, type, 0, false, defaultValue, IdentityType.NA);
    if (type == ExtractType.String || type == ExtractType.List)
      throw new IllegalArgumentException("VARCHAR types must have a size specified");
  }

  <T> Extract<T> extractString(Function<T, String> f) {
    return switch (this.type) {
      case ExtractType.String ->
          new Extract<>(this, null, new TrimToSize<>(size, f, field), null, null);
      case ExtractType.Text -> new Extract<>(this, null, f, null, null);
      default -> throw new IllegalArgumentException("Wrong extractor for specified type");
    };
  }

  <T> Extract<T> extractList(Function<T, List<String>> f) {
    return new Extract<>(this, new TrimAllToSize<>(size, f, field), null, null, null);
  }

  <T> Extract<T> extractInt(Function<T, Integer> f) {
    return new Extract<>(this, null, null, f, null);
  }

  <T> Extract<T> extractLong(Function<T, Long> f) {
    return new Extract<>(this, null, null, null, f);
  }

  public String toSql() {
    switch (identityType) {
      case Generated:
        return String.format(
            "%s %s %s", field, type.getSqlType(), "GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY");
      case Manual:
        return String.format("%s %s %s", field, type.getSqlType(), "PRIMARY KEY");
      case NA:
        break;
    }
    return String.format(
        "%s %s%s %s %s",
        field,
        type.getSqlType(),
        size == 0 ? "" : String.format("(%d)", size),
        unique ? "unique" : "",
        Objects.equals(defaultValue, "") ? "" : String.format("DEFAULT %s", defaultValue));
  }

  static String trimField(String field, String content, int maximum) {
    if (content == null || content.length() <= maximum) {
      return content;
    }
    LOGGER.debug("Trimming field {} to size {} down from {}", field, maximum, content.length());
    return content.substring(0, maximum);
  }

  private record TrimToSize<T>(int size, Function<T, String> extract, String field)
      implements Function<T, String> {
    @Override
    public String apply(T t) {
      return trimField(field, extract.apply(t), size);
    }
  }

  public static <T, R> List<R> mapper(T[] a, Function<T, R> mapFunction) {
    return Arrays.stream(a).map(mapFunction).toList();
  }

  private record TrimAllToSize<T>(int size, Function<T, List<String>> extract, String field)
      implements Function<T, List<String>> {
    @Override
    public List<String> apply(T t) {
      List<String> s = extract.apply(t);
      if (s == null) return null;
      return s.stream().map(v -> trimField(field, v, size)).toList();
    }
  }
}
